# Mosquito CNV pipeline specification

* Version: 1.0.0
* Authors: Alistair Miles, Eric Lucas, Kevin Palis, Jessica Way

This document specifies a pipeline for calling Copy Number Variants (CNVs) for a
cohort of multiple samples. The pipeline inclludes an HMM step followed by coverage calls and target regions pipelines to improve acuracy. 


## Inputs

* A manifest specifying a set of samples to be called.

* For each sample, a BAM file containing analysis-ready sequence read
  alignments, produced by the [mosquito short read alignment
  pipeline](short-read-alignment-vector.md).

* A  unique sample set ID

* Reference genome sequence (FASTA format).


## Outputs

* CNV HMM output

* CNV Coverage Calls output

* CNV targeted regions output


## Software

* R version 3.6.1


## Pipeline

### Sub-pipeline: CNV HMM 

#### Step: Windowed Coverage
**Description:** Divides the genome into 300bp windows and counts the number of reads for each window.\
**Inputs:** Bam file, 1 per sample\
**Outputs:** Windowed count reads file, 1 row per window, 1 file per sample \
**Software:** Python virtualenv cnv37\
Steps in CNV_pipeline/scripts/get_windowed_coverage_and_diagnostic_reads.sh\
```bash
  #For each chromosome, run counts_for_HMM.py -- a script that will calculate the coverage at every x bp along a genomic region for a given bamfile
  python ${scriptsfolder}/counts_for_HMM.py \
	       $bamfile \
	       $chrom \
	       300 300 10 \
	       ${coveragefolder}/${chrom}/counts_for_HMM_${samplename}_${chrom}_output.csv \
	       > ${coveragefolder}/${chrom}/coveragelogs/counts_for_HMM_${samplename}_${chrom}.log 2>&1

```

#### Step: Calculate Coverage Summary Stats
**Description:** Analyzes the read count for each sample. Computes a GC normalization table that describes the mean read count for each percentile of GC. Computes overall coverage variance \
**Inputs:** Windowed count reads file, 1 per sample\
**Outputs:** Summary statistics file, 1 per sample\
**Software:** Python virtualenv cnv37\
Steps in CNV_pipeline/scripts/get_coverage_stats_by_sample_set_vobs.sh\
```bash
  #Runs calculate_median_coverage_by_GC.py which is a script that calculates the median coverage by GC window for a list of samples from Ag1000G
  python $scriptsfolder/calculate_median_coverage_by_GC.py 0.9 \
                                                          $accessibility_file \
                                                          0.5 \
                                                          $mapqprop_file \
                                                          $manifest \
                                                          $GC_content_file \
                                                          $workingfolder \
                                                          $sample_group_id \
                                                          > $workingfolder/calculate_mean_coverage_by_GC_09_05_${sample_group_id}.log 2>&1
```

#### Step: CNV HMM
**Description:** Normalizes the read count for each sample by dividing by the modal coverage for each windw. Fits an HM to the normalized read counts , \
**Inputs:** Windowed count reads file, 1 per sample. Coverage variance statistics, 1 per sample\
**Outputs:** Normalized coverage values, 1 per window, per sample. Copy number state, 1 per window, per sample. \
**Software:** Python virtualenv cnv37\
Steps in CNV_pipeline/scripts/coverage_HMM_vobs.sh\
```bash
  #Runs HMM_process.py which is a script that runs an mHMM on coverage counts obtained from a bamfile, using normalisation based on the mean coverage per GC bin over the whole genome of the individual.
  python ${scriptsfolder}/HMM_process.py \
       $manifest \
       $chrom \
       $coveragefolder \
       $GC_content_file \
       $coverage_by_GC_file \
       $coverage_variance_file \
       $mapq_prop_file \
       0.5 \
       > ${coveragefolder}/${chrom}/HMM_logs_${species}/HMM_${chrom}.log 2>&1
```


### Sub-pipeline: CNV Coverage Calls

#### Step: CNV Coverage Calls
**Description:** Uses the predicted copy number state values generated by the HMM to call CNVs. Calls CNVs based on the change in predicted copy number within consecutive windows. Calls variants by grouping CNVs observed in multiple samples, as determined by the start and end coordinates. \
**Inputs:** Copy number state files. 1 per window per sample.\
**Outputs:** File similar to VCF. Lists variants with genotypes for each sample. 1 per sample set.\
**Software:** R version 3.6.1\
Steps in CNV_pipeline/scripts/coverage_CNVs_vobs.sh\
```bash
R-3.6.1 --slave -f $scriptsfolder/CNV_analysis.r --args $chrom \
                                                        $manifest \
                                                        $coverage_variance_file \
                                                        $gene_coordinates_file \
                                                        $detox_genes_file \
                                                        $workingfolder \
                                                        $ncores \
                                                        $outputfolder \
                                                        $metadata \
                                                        > $coveragefolder/$chrom/CNV_analysis_logs/CNV_analysis_${output_name}.log 2>&1
```


### Sub-pipeline: CNV Targeted Regions 

#### Step: Extract Diagnostic Reads
Note: this is currently combined with the windowed coverage step at the beginning of the pipeline\
**Description:** Extract diagnostic reads needed to call the CNVs in a catalog of CNVs known to be important for resistance. \
**Inputs:** Bam files, 1 per sample. \
**Outputs:** \
**Software:** Python virtualenv cnv37\
Steps in CNV_pipeline/scripts/get_windowed_coverage_and_diagnostic_reads.sh\
```bash
  # Get the discordant reads
  # Runs SSFA.py for every chromosome: This script goes through an alignment file and records the positions of reads within a specified region whose mates map to a different chromosome or discordantly on the same chromosome
  SSFA_script=$scriptsfolder/SSFA.py
  SSFAfolder=$outputfolder/diagnostic_reads/SSFA
  python $SSFA_script $bamfile 2R 3425000:3650000 ${SSFAfolder}/2R/Ace1_region/${samplename}_Ace1_SSFA_output.csv 10 > ${SSFAfolder}/2R/Ace1_region/SSFAlogs/${samplename}_Ace1_SSFA_output.log 2>&1
  python $SSFA_script $bamfile 2R 28460000:28570000 ${SSFAfolder}/2R/Cyp6_region/${samplename}_CYP6_SSFA_output.csv 10 > ${SSFAfolder}/2R/Cyp6_region/SSFAlogs/${samplename}_CYP6_SSFA_output.log 2>&1
  python $SSFA_script $bamfile 3R 6900000:7000000 ${SSFAfolder}/3R/Cyp6zm_region/${samplename}_CYP6ZM_SSFA_output.csv 10 > ${SSFAfolder}/3R/Cyp6zm_region/SSFAlogs/${samplename}_CYP6ZM_SSFA_output.log 2>&1
  python $SSFA_script $bamfile 3R 28570000:28620000 ${SSFAfolder}/3R/Gste_region/${samplename}_GST_SSFA_output.csv 10 > ${SSFAfolder}/3R/Gste_region/SSFAlogs/${samplename}_GST_SSFA_output.log 2>&1
  python $SSFA_script $bamfile X 15220000:15255000 ${SSFAfolder}/X/Cyp9k1_region/${samplename}_CYP9K1_SSFA_output.csv 10 > ${SSFAfolder}/X/Cyp9k1_region/SSFAlogs/${samplename}_CYP9K1_SSFA_output.log 2>&1

  # Get the soft clipped reads
  # Runs breakpoint_detector.py for every chrom: This script goes through an alignment file and records the positions at which soft_clipping is detected in the aligned reads
  breakpoints_script=$scriptsfolder/breakpoint_detector.py
  breakpointsfolder=$outputfolder/diagnostic_reads/breakpoints
  python $breakpoints_script $bamfile 2R 3425000:3650000 ${breakpointsfolder}/2R/Ace1_region/${samplename}_Ace1_breakpoints_output 10 > ${breakpointsfolder}/2R/Ace1_region/breakpointlogs/${samplename}_Ace1_breakpoints_output.log 2>&1
  python $breakpoints_script $bamfile 2R 28460000:28570000 ${breakpointsfolder}/2R/Cyp6_region/${samplename}_CYP6_breakpoints_output 10 > ${breakpointsfolder}/2R/Cyp6_region/breakpointlogs/${samplename}_CYP6_breakpoints_output.log 2>&1
  python $breakpoints_script $bamfile 3R 6900000:7000000 ${breakpointsfolder}/3R/Cyp6zm_region/${samplename}_CYP6ZM_breakpoints_output 10 > ${breakpointsfolder}/3R/Cyp6zm_region/breakpointlogs/${samplename}_CYP6ZM_breakpoints_output.log 2>&1
  python $breakpoints_script $bamfile 3R 28570000:28620000 ${breakpointsfolder}/3R/Gste_region/${samplename}_GST_breakpoints_output 10 > ${breakpointsfolder}/3R/Gste_region/breakpointlogs/${samplename}_GST_breakpoints_output.log 2>&1
  python $breakpoints_script $bamfile X 15220000:15255000 ${breakpointsfolder}/X/Cyp9k1_region/${samplename}_CYP9K1_breakpoints_output 10 > ${breakpointsfolder}/X/Cyp9k1_region/breakpointlogs/${samplename}_CYP9K1_breakpoints_output.log 2>&1

```

#### Step: Target Regions CNV Calls
**Description:** \
**Inputs:** \
**Outputs:** text file with genotypes \
**Software:** R version 3.6.1\
Steps in CNV_pipeline/scripts/target_regions_analysis_vobs.sh\
```bash
  R-3.6.1 --slave -f $scriptsfolder/target_regions_analysis.r --args $manifest \
                                                                   $gene_coordinates_file \
                                                                   $metadata \
                                                                   $species_id_file \
                                                                   $coverage_variance_file \
                                                                   $coveragefolder \
                                                                   $diagnostic_reads_folder \
                                                                   $plotting_functions_file \
                                                                   $ncores \
                                                                   > target_regions_analysis/target_regions_analysis.log 2>&1


```

## Convert outputs to zarr and vcf 

## Implementation notes



## Change log

